//Created by Hugh Wallace for DESN2000 RENEW Boardgame.
//This is code for 4 players with buttons, LCD's and Neopixel LED's


#include <Wire.h> // Library for I2C communication
#include <Servo.h> // library for servo motors
#include <LiquidCrystal_I2C.h> // Library for LCD
#include <Adafruit_NeoPixel.h> // Library for LED's

#define MAX_SALARIES      41
#define MAX_GENERATORS    4

#define P1PIN             A0
#define P2PIN             A1
#define P3PIN             A2
#define P4PIN             A3

#define LED_PIN           6

#define LED_COUNT         80

// Declare our NeoPixel strip object:
Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);

const int startSalary = 0;
const int buttonPin = 2;
const int disasterTime = 10000;
const int disasterPin = 2;
const int servoPin1 = 9;
const int servoPin2 = 10;

Servo servo1; 
Servo servo2;

int cursorPosition_P1 = 0;
int salary_P1 = 0;
int generators_P1 = 0;
int renewable_P1 = 0;

int cursorPosition_P2 = 0;
int salary_P2 = 0;
int generators_P2 = 0;
int renewable_P2 = 0;

int cursorPosition_P3 = 0;
int salary_P3 = 0;
int generators_P3 = 0;
int renewable_P3 = 0;

int cursorPosition_P4 = 0;
int salary_P4 = 0;
int generators_P4 = 0;
int renewable_P4 = 0;

bool renewable_1 = true;
bool renewable_2 = true;
bool renewable_3 = true;
bool renewable_4 = true;

int level = 90;
int pos = level + 30; // variable to store the servo position
int pos2 = pos + 40;

int activeButton = 0;
int activeButton2 = 0;
int activeButton3 = 0;
int activeButton4 = 0;

int player_1_section_tracker = 0;
int player_2_section_tracker = 0;
int player_3_section_tracker = 0;
int player_4_section_tracker = 0;

int salaries[] = {0, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 300, 310, 320, 330, 340, 350, 360, 370, 380, 390, 400, 410, 420, 430, 440, 450, 460, 470, 480};

// Navigation button variables
int readKey = 0;
int readKey2 = 0;
int readKey3 = 0;
int readKey4 = 0;

long previousMillis = 0;
long interval = 100;           // interval at which to check analog input (milliseconds)

LiquidCrystal_I2C lcd_P2 = LiquidCrystal_I2C(0x27, 20, 4); // Change to (0x27,16,2) for 16x2 LCD.
LiquidCrystal_I2C lcd_P4 = LiquidCrystal_I2C(0x26, 20, 4); // Change to (0x27,16,2) for 16x2 LCD.
LiquidCrystal_I2C lcd_P1 = LiquidCrystal_I2C(0x23, 20, 4); // Change to (0x27,16,2) for 16x2 LCD.
LiquidCrystal_I2C lcd_P3 = LiquidCrystal_I2C(0x21, 20, 4); // Change to (0x27,16,2) for 16x2 LCD.

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);

  //Set up special button
  pinMode(buttonPin, INPUT_PULLUP);

  //set up servos
  servo1.attach(servoPin1);
  servo2.attach(servoPin2);

  // initialise the LED strip
  strip.begin();           // INITIALIZE NeoPixel strip object (REQUIRED)
  strip.clear();
  strip.show();            // Turn OFF all pixels ASAP
  strip.setBrightness(50); // Set BRIGHTNESS to about 1/5 (max = 255)

  //Send colours of the players around
  colorWipe(strip.Color(255, 51, 119), 200, 0, 20); // pink
  colorWipe(strip.Color(0, 0, 250), 200, 20, 40); //blue P2 etc
  colorWipe(strip.Color(255, 155, 0), 200, 40, 60); //yellow
  colorWipe(strip.Color(0, 255, 0), 200, 60, 80); //green
  
  
  // Initializes and clears the LCD screen
  lcd_P1.init();   // initializing the LCD
  lcd_P1.backlight(); // Enable or Turn On the backlight
  lcd_P1.clear();

  lcd_P2.init();   // initializing the LCD
  lcd_P2.backlight(); // Enable or Turn On the backlight
  lcd_P2.clear();

  lcd_P3.init();   // initializing the LCD
  lcd_P3.backlight(); // Enable or Turn On the backlight
  lcd_P3.clear();

  lcd_P4.init();   // initializing the LCD
  lcd_P4.backlight(); // Enable or Turn On the backlight
  lcd_P4.clear();
  
  // Start game message
  lcd_P1.clear();
  lcd_P1.setCursor(5,1);
  lcd_P1.print("Welcome to");
  lcd_P1.setCursor(7,2);
  lcd_P1.print("RENEW");
  lcd_P2.clear();
  lcd_P2.setCursor(5,1);
  lcd_P2.print("Welcome to");
  lcd_P2.setCursor(7,2);
  lcd_P2.print("RENEW");
  lcd_P3.clear();
  lcd_P3.setCursor(5,1);
  lcd_P3.print("Welcome to");
  lcd_P3.setCursor(7,2);
  lcd_P3.print("RENEW");
  lcd_P4.clear();
  lcd_P4.setCursor(5,1);
  lcd_P4.print("Welcome to");
  lcd_P4.setCursor(7,2);
  lcd_P4.print("RENEW");
  
  delay(3000);
  
  lcd_P1.clear();
  lcd_P1.setCursor(5,1);
  lcd_P1.print("LET'S PLAY!");
  lcd_P2.clear();
  lcd_P2.setCursor(5,1);
  lcd_P2.print("LET'S PLAY!");
  lcd_P3.clear();
  lcd_P3.setCursor(5,1);
  lcd_P3.print("LET'S PLAY!");
  lcd_P4.clear();
  lcd_P4.setCursor(5,1);
  lcd_P4.print("LET'S PLAY!");
  
  delay(3000);
  
  lcd_P1.clear();
  lcd_P2.clear();
  lcd_P3.clear();
  lcd_P4.clear();

  strip.clear();
  strip.show();

  mainMenuDraw_P1();
  drawCursor_P1();
  
  mainMenuDraw_P2();
  drawCursor_P2();
  
  mainMenuDraw_P3();
  drawCursor_P3();
  
  mainMenuDraw_P4();
  drawCursor_P4();

  leds_P1(generators_P1, salary_P1);
  leds_P2(generators_P2, salary_P2);
  leds_P3(generators_P3, salary_P3);
  leds_P4(generators_P4, salary_P4);
  
}

void loop() {
  // put your main code here, to run repeatedly:
  
  operateMainMenu_P1();
  salaryClick_P1();
  generatorClick_P1();
  renewableClick_P1();
  finishedClick_P1();

  operateMainMenu_P2(); 
  salaryClick_P2();
  generatorClick_P2();
  renewableClick_P2();
  finishedClick_P2();
  
  operateMainMenu_P3();
  salaryClick_P3();
  generatorClick_P3();
  renewableClick_P3();
  finishedClick_P3();
  
  operateMainMenu_P4();
  salaryClick_P4();
  generatorClick_P4();
  renewableClick_P4();
  finishedClick_P4();

  int buttonState = digitalRead(disasterPin);
  if (buttonState == LOW){
    disaster();
  }
  
}
void disaster(){
  uint32_t red = strip.Color(255, 0, 0);
  
    theaterChase(red, 5, 0, LED_COUNT);
    
    lcd_P1.clear();
    lcd_P1.setCursor(7,1);
    lcd_P1.print("DANGER");
    lcd_P2.clear();
    lcd_P2.setCursor(7,1);
    lcd_P2.print("DANGER");
    lcd_P3.clear();
    lcd_P3.setCursor(7,1);
    lcd_P3.print("DANGER");
    lcd_P4.clear();
    lcd_P4.setCursor(7,1);
    lcd_P4.print("DANGER");

    delay(3000);

    lcd_P1.clear();
    lcd_P1.setCursor(2,1);
    lcd_P1.print("NATURAL DISASTER");
    lcd_P1.setCursor(6,2);
    lcd_P1.print("IMMINENT");
    lcd_P2.clear();
    lcd_P2.setCursor(2,1);
    lcd_P2.print("NATURAL DISASTER");
    lcd_P2.setCursor(6,2);
    lcd_P2.print("IMMINENT");
    lcd_P3.clear();
    lcd_P3.setCursor(2,1);
    lcd_P3.print("NATURAL DISASTER");
    lcd_P3.setCursor(6,2);
    lcd_P3.print("IMMINENT");
    lcd_P4.clear();
    lcd_P4.setCursor(2,1);
    lcd_P4.print("NATURAL DISASTER");
    lcd_P4.setCursor(6,2);
    lcd_P4.print("IMMINENT");
    
    delay(1500);

    lcd_P1.noBacklight();
    lcd_P2.noBacklight();
    lcd_P3.noBacklight();
    lcd_P4.noBacklight();

    int wait = 150;
    unsigned long start = millis ();

    servo1.write(pos);
    servo2.write(pos);

    while (millis () - start <= disasterTime) {
      servo1.write(pos);
      servo2.write(pos);
      delay(wait);
      servo1.write(pos2);
      servo2.write(pos2);
      delay(wait); 
    }

    servo1.write(level); //Make them level again.
    servo2.write(level);
    
    lcd_P1.backlight();
    lcd_P2.backlight();
    lcd_P3.backlight();
    lcd_P4.backlight();
       
    mainMenuDraw_P1();
    mainMenuDraw_P2();
    mainMenuDraw_P3();
    mainMenuDraw_P4();

    drawCursor_P1();
    drawCursor_P2();
    drawCursor_P3();
    drawCursor_P4();      
}
// This function will generate the 4 menu items that can fit on the screen. They will change as you scroll through your menu. Up and down arrows will indicate your current menu position.
void mainMenuDraw_P1() {
  lcd_P1.clear();
  lcd_P1.setCursor(1, 0);
  lcd_P1.print("SALARY:");
  lcd_P1.setCursor(15, 0);
  lcd_P1.print(salaries[salary_P1]);
  lcd_P1.setCursor(14, 0);
  lcd_P1.print("$");
  lcd_P1.setCursor(1, 1);
  lcd_P1.print("UPGRADES:");
  lcd_P1.setCursor(15, 1);
  lcd_P1.print(generators_P1);
  lcd_P1.setCursor(1,2);
  lcd_P1.print("RENEWABLES:");
  lcd_P1.setCursor(15, 2);
  
  if(renewable_1 == true){
    lcd_P1.print("YES");
  }
  else{
    lcd_P1.print("NO");
  }
  lcd_P1.setCursor(1,3);
  lcd_P1.print("FINISHED?");
  leds_P1(generators_P1, salary_P1);
}
void mainMenuDraw_P2() {
  lcd_P2.clear();
  lcd_P2.setCursor(1, 0);
  lcd_P2.print("SALARY:");
  lcd_P2.setCursor(15, 0);
  lcd_P2.print(salaries[salary_P2]);
  lcd_P2.setCursor(14, 0);
  lcd_P2.print("$");
  lcd_P2.setCursor(1, 1);
  lcd_P2.print("UPGRADES:");
  lcd_P2.setCursor(15, 1);
  lcd_P2.print(generators_P2);
  lcd_P2.setCursor(1,2);
  lcd_P2.print("RENEWABLES:");
  lcd_P2.setCursor(15, 2);
  
  if(renewable_2 == true){
    lcd_P2.print("YES");
  }
  else{
    lcd_P2.print("NO");
  }
  
  lcd_P2.setCursor(1,3);
  lcd_P2.print("FINISHED?");
  leds_P2(generators_P2, salary_P2);
}
void mainMenuDraw_P3() {
  lcd_P3.clear();
  lcd_P3.setCursor(1, 0);
  lcd_P3.print("SALARY:");
  lcd_P3.setCursor(15, 0);
  lcd_P3.print(salaries[salary_P3]);
  lcd_P3.setCursor(14, 0);
  lcd_P3.print("$");
  lcd_P3.setCursor(1, 1);
  lcd_P3.print("UPGRADES:");
  lcd_P3.setCursor(15, 1);
  lcd_P3.print(generators_P3);
  lcd_P3.setCursor(1,2);
  lcd_P3.print("RENEWABLES:");
  lcd_P3.setCursor(15, 2);
  
  if(renewable_3 == true){
    lcd_P3.print("YES");
  }
  else{
    lcd_P3.print("NO");
  }
  
  lcd_P3.setCursor(1,3);
  lcd_P3.print("FINISHED?");
  leds_P3(generators_P3, salary_P3);
}
void mainMenuDraw_P4() {
  lcd_P4.clear();
  lcd_P4.setCursor(1, 0);
  lcd_P4.print("SALARY:");
  lcd_P4.setCursor(15, 0);
  lcd_P4.print(salaries[salary_P4]);
  lcd_P4.setCursor(14, 0);
  lcd_P4.print("$");
  lcd_P4.setCursor(1, 1);
  lcd_P4.print("UPGRADES:");
  lcd_P4.setCursor(15, 1);
  lcd_P4.print(generators_P4);
  lcd_P4.setCursor(1,2);
  lcd_P4.print("RENEWABLES:");
  lcd_P4.setCursor(15, 2);
  
  if(renewable_4 == true){
    lcd_P4.print("YES");
  }
  else{
    lcd_P4.print("NO");
  }
  lcd_P4.setCursor(1,3);
  lcd_P4.print("FINISHED?");
  leds_P4(generators_P4, salary_P4);
}

//Main menu
void operateMainMenu_P1() {
  //Serial.println(activeButton);
  activeButton = 0;
  readKey = analogRead(P1PIN);
  unsigned long currentMillis = millis();
 
  if(readKey < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey = analogRead(P1PIN);
  }

  if (activeButton == 0 && player_1_section_tracker == 0 && readKey > 600) {
    int button;
    button = buttonRead_P1(readKey);
    //Serial.print(activeButton);
    switch (button) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        button = 0;
        switch (cursorPosition_P1) { // The case that is selected here is dependent on which menu page you are on and where the cursor is.
          case 0:
            salaryClick_P1(); // this case is when the user clicks the salary they have 
            player_1_section_tracker = 1;
            break;
          case 1:
            generatorClick_P1();  // this case is when the user clicks the generators they have
            player_1_section_tracker = 2;
            break;
          case 2:
            renewableClick_P1();// this case is to select if renewable or not
            player_1_section_tracker = 3;
            break;
          case 3:
            finishedClick_P1();  // this case is when the user clicks to add upgrades
            theaterChaseRainbow(5);
            player_1_section_tracker = 4;
            
            break;
       }
        activeButton = 1;
        drawCursor_P1();
        break;
      case 2: // Scrolling up the menu
        button = 0;
        if (cursorPosition_P1 == 0) { //At top of menu
          cursorPosition_P1 = 0;
        }
        else if (cursorPosition_P1 == 1) {
          cursorPosition_P1 = 0;
        }
        else if (cursorPosition_P1 == 2) {
          cursorPosition_P1 = 1;
        }
        else if (cursorPosition_P1 == 3) {
          cursorPosition_P1 = 2;
        }
        
        activeButton = 1;
        drawCursor_P1();
        break;
      case 3: // Scrolling down the menu
       button = 0;
        if (cursorPosition_P1 == 0) { //At top of menu
          cursorPosition_P1 = 1;
        }
        else if (cursorPosition_P1 == 1) {
          cursorPosition_P1 = 2;
        }
        else if (cursorPosition_P1 == 2) {
          cursorPosition_P1 = 3;        
        }
        else if (cursorPosition_P1 == 3) {
          cursorPosition_P1 = 3;
        }

        activeButton = 1;
        drawCursor_P1();
        break;
    }
    readKey = 0;
  }
}
void operateMainMenu_P2() {
  
  activeButton2 = 0;
  readKey2 = analogRead(P2PIN);
  unsigned long currentMillis = millis();
 
  if(readKey2 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey2 = analogRead(P2PIN);
  }

  if (activeButton2 == 0 && player_2_section_tracker == 0 && readKey2 > 600) {
    int button2;
    button2 = buttonRead_P2(readKey2);
    switch (button2) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        button2 = 0;
        switch (cursorPosition_P2) { // The case that is selected here is dependent on which menu page you are on and where the cursor is.
          case 0:
            salaryClick_P2(); // this case is when the user clicks the salary they have 
            player_2_section_tracker = 1;
            break;
          case 1:
            generatorClick_P2();  // this case is when the user clicks the generators they have
            player_2_section_tracker = 2;
            break;
          case 2:
            renewableClick_P2();// this case is to select if renewable or not
            player_2_section_tracker = 3;
            break;
          case 3:
            finishedClick_P2();  // this case is when the user clicks to add upgrades
            theaterChaseRainbow(5);
            player_2_section_tracker = 4;
            break;
       }
        activeButton2 = 1;
        drawCursor_P2();
        break;
      case 2: // Scrolling up the menu
        button2 = 0;
        if (cursorPosition_P2 == 0) { //At top of menu
          cursorPosition_P2 = 0;
        }
        else if (cursorPosition_P2 == 1) {
          cursorPosition_P2 = 0;
        }
        else if (cursorPosition_P2 == 2) {
          cursorPosition_P2 = 1;
        }
        else if (cursorPosition_P2 == 3) {
          cursorPosition_P2 = 2;
        }
        activeButton2 = 1;
        drawCursor_P2();
        break;
      case 3: // Scrolling down the menu
       button2 = 0;
        if (cursorPosition_P2 == 0) { //At top of menu
          cursorPosition_P2 = 1;
        }
        else if (cursorPosition_P2 == 1) {
          cursorPosition_P2 = 2;
        }
        else if (cursorPosition_P2 == 2) {
          cursorPosition_P2 = 3;        
        }
        else if (cursorPosition_P2 == 3) {
          cursorPosition_P2 = 3;
        }

        activeButton2 = 1;
        drawCursor_P2();
        break;
    }
    readKey2 = 0;
  }
}
void operateMainMenu_P3() {
  
  activeButton3 = 0;
  readKey3 = analogRead(P3PIN);
  unsigned long currentMillis = millis();
 
  if(readKey3 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey3 = analogRead(P3PIN);
  }
  
  if (activeButton3 == 0 && player_3_section_tracker == 0 && readKey3 > 600) {
    int button3;
    button3 = buttonRead_P3(readKey3);
    switch (button3) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        button3 = 0;
        switch (cursorPosition_P3) { // The case that is selected here is dependent on which menu page you are on and where the cursor is.
          case 0:
            salaryClick_P3(); // this case is when the user clicks the salary they have 
            player_3_section_tracker = 1;
            break;
          case 1:
            generatorClick_P3();  // this case is when the user clicks the generators they have
            player_3_section_tracker = 2;
            break;
          case 2:
            renewableClick_P3();// this case is to select if renewable or not
            player_3_section_tracker = 3;
            break;
          case 3:
            finishedClick_P3();  // this case is when the user clicks to add upgrades
            theaterChaseRainbow(5);
            player_3_section_tracker = 4;
            break;
       }
        activeButton3 = 1;
        drawCursor_P3();
        break;
      case 2: // Scrolling up the menu
        button3 = 0;
        if (cursorPosition_P3 == 0) { //At top of menu
          cursorPosition_P3 = 0;
        }
        else if (cursorPosition_P3 == 1) {
          cursorPosition_P3 = 0;
        }
        else if (cursorPosition_P3 == 2) {
          cursorPosition_P3 = 1;
        }
        else if (cursorPosition_P3 == 3) {
          cursorPosition_P3 = 2;
        }
        
        activeButton3 = 1;
        drawCursor_P3();
        break;
      case 3: // Scrolling down the menu
       button3 = 0;
        if (cursorPosition_P3 == 0) { //At top of menu
          cursorPosition_P3 = 1;
        }
        else if (cursorPosition_P3 == 1) {
          cursorPosition_P3 = 2;
        }
        else if (cursorPosition_P3 == 2) {
          cursorPosition_P3 = 3;        
        }
        else if (cursorPosition_P3 == 3) {
          cursorPosition_P3 = 3;
        }

        activeButton3 = 1;
        drawCursor_P3();
        break;
    }
    readKey3 = 0;
  }
}
void operateMainMenu_P4() {
  
  activeButton4 = 0;
  readKey4 = analogRead(P4PIN);
  unsigned long currentMillis = millis();
 
  if(readKey4 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey4 = analogRead(P4PIN);
  }
  if (activeButton4 == 0 && player_4_section_tracker == 0 && readKey4 > 600) {
    int button4;
    button4 = buttonRead_P4(readKey4);
    switch (button4) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        button4 = 0;
        switch (cursorPosition_P4) { // The case that is selected here is dependent on which menu page you are on and where the cursor is.
          case 0:
            salaryClick_P4(); // this case is when the user clicks the salary they have 
            player_4_section_tracker = 1;
            break;
          case 1:
            generatorClick_P4();  // this case is when the user clicks the generators they have
            player_4_section_tracker = 2;
            break;
          case 2:
            renewableClick_P4();// this case is to select if renewable or not
            player_4_section_tracker = 3;
            break;
          case 3:
            finishedClick_P4();  // this case is when the user clicks to add upgrades
            theaterChaseRainbow(5);
            player_4_section_tracker = 4;
            break;
       }
        activeButton4 = 1;
        drawCursor_P4();
        break;
      case 2: // Scrolling up the menu
        button4 = 0;
        if (cursorPosition_P4 == 0) { //At top of menu
          cursorPosition_P4 = 0;
        }
        else if (cursorPosition_P4 == 1) {
          cursorPosition_P4 = 0;
        }
        else if (cursorPosition_P4 == 2) {
          cursorPosition_P4 = 1;
        }
        else if (cursorPosition_P4 == 3) {
          cursorPosition_P4 = 2;
        }
        
        activeButton4 = 1;
        drawCursor_P4();
        break;
      case 3: // Scrolling down the menu
       button4 = 0;
        if (cursorPosition_P4 == 0) { //At top of menu
          cursorPosition_P4 = 1;
        }
        else if (cursorPosition_P4 == 1) {
          cursorPosition_P4 = 2;
        }
        else if (cursorPosition_P4 == 2) {
          cursorPosition_P4 = 3;        
        }
        else if (cursorPosition_P4 == 3) {
          cursorPosition_P4 = 3;
        }

        activeButton4 = 1;
        drawCursor_P4();
        break;
    }
    readKey4 = 0;
  }
}
// When called, this function will erase the current cursor and redraw it based on the cursorPosition and menuPage variables.
void drawCursor_P1() {

   for (int x = 0; x < 4; x++) {     // Erases current cursor
      lcd_P1.setCursor(0, x);
      lcd_P1.print(" ");
   }
   for (int x = 0; x < 4; x++) {     // Erases current RHS cursor
      lcd_P1.setCursor(18, x);
      lcd_P1.print("  ");
   }
  
  if(player_1_section_tracker == 0){
    // Should set the cursor
    if (cursorPosition_P1 == 0) {
        lcd_P1.setCursor(0,0);
        lcd_P1.print(">");
    }
    else if (cursorPosition_P1 == 1) {
        lcd_P1.setCursor(0,1);
        lcd_P1.print(">");
    }
    else if (cursorPosition_P1 == 2) {
        lcd_P1.setCursor(0,2);
        lcd_P1.print(">");
    }
    else if (cursorPosition_P1 == 3) {
        lcd_P1.setCursor(0,3);
        lcd_P1.print(">");
    }
  }
  else{
    // Should set the editing cursor if not on main scroll
    if (cursorPosition_P1 == 0) {
        lcd_P1.setCursor(18,0);
        lcd_P1.print("<<");
    }
    else if (cursorPosition_P1 == 1) {
        lcd_P1.setCursor(18,1);
        lcd_P1.print("<<");
    }
    else if (cursorPosition_P1 == 2) {
        lcd_P1.setCursor(18,2);
        lcd_P1.print("<<");
    }
    else if (cursorPosition_P1 == 3) {
        lcd_P1.setCursor(18,3);
        lcd_P1.print("<<");
    }
  }
}
void drawCursor_P2() {

   for (int x = 0; x < 4; x++) {     // Erases current cursor
      lcd_P2.setCursor(0, x);
      lcd_P2.print(" ");
   }
   for (int x = 0; x < 4; x++) {     // Erases current RHS cursor
      lcd_P2.setCursor(18, x);
      lcd_P2.print("  ");
   }
  
  if(player_2_section_tracker == 0){
    // Should set the cursor
    if (cursorPosition_P2 == 0) {
        lcd_P2.setCursor(0,0);
        lcd_P2.print(">");
    }
    else if (cursorPosition_P2 == 1) {
        lcd_P2.setCursor(0,1);
        lcd_P2.print(">");
    }
    else if (cursorPosition_P2 == 2) {
        lcd_P2.setCursor(0,2);
        lcd_P2.print(">");
    }
    else if (cursorPosition_P2 == 3) {
        lcd_P2.setCursor(0,3);
        lcd_P2.print(">");
    }
  }
  else{
    // Should set the editing cursor if not on main scroll
    if (cursorPosition_P2 == 0) {
        lcd_P2.setCursor(18,0);
        lcd_P2.print("<<");
    }
    else if (cursorPosition_P2 == 1) {
        lcd_P2.setCursor(18,1);
        lcd_P2.print("<<");
    }
    else if (cursorPosition_P2 == 2) {
        lcd_P2.setCursor(18,2);
        lcd_P2.print("<<");
    }
    else if (cursorPosition_P2 == 3) {
        lcd_P2.setCursor(18,3);
        lcd_P2.print("<<");
    }
  }
}
void drawCursor_P3() {

   for (int x = 0; x < 4; x++) {     // Erases current LHS cursor
      lcd_P3.setCursor(0, x);
      lcd_P3.print(" ");
   }
   for (int x = 0; x < 4; x++) {     // Erases current RHS cursor
      lcd_P3.setCursor(18, x);
      lcd_P3.print("  ");
   }
  
  if(player_3_section_tracker == 0){
    // Should set the cursor
    if (cursorPosition_P3 == 0) {
        lcd_P3.setCursor(0,0);
        lcd_P3.print(">");
    }
    else if (cursorPosition_P3 == 1) {
        lcd_P3.setCursor(0,1);
        lcd_P3.print(">");
    }
    else if (cursorPosition_P3 == 2) {
        lcd_P3.setCursor(0,2);
        lcd_P3.print(">");
    }
    else if (cursorPosition_P3 == 3) {
        lcd_P3.setCursor(0,3);
        lcd_P3.print(">");
    }
  }
  else{
    // Should set the editing cursor if not on main scroll
    if (cursorPosition_P3 == 0) {
        lcd_P3.setCursor(18,0);
        lcd_P3.print("<<");
    }
    else if (cursorPosition_P3 == 1) {
        lcd_P3.setCursor(18,1);
        lcd_P3.print("<<");
    }
    else if (cursorPosition_P3 == 2) {
        lcd_P3.setCursor(18,2);
        lcd_P3.print("<<");
    }
    else if (cursorPosition_P3 == 3) {
        lcd_P3.setCursor(18,3);
        lcd_P3.print("<<");
    }
  }
}
void drawCursor_P4() {

   for (int x = 0; x < 4; x++) {     // Erases current cursor
      lcd_P4.setCursor(0, x);
      lcd_P4.print(" ");
   }
   for (int x = 0; x < 4; x++) {     // Erases current RHS cursor
      lcd_P4.setCursor(18, x);
      lcd_P4.print("  ");
   }
  
  if(player_4_section_tracker == 0){
    // Should set the cursor
    if (cursorPosition_P4 == 0) {
        lcd_P4.setCursor(0,0);
        lcd_P4.print(">");
    }
    else if (cursorPosition_P4 == 1) {
        lcd_P4.setCursor(0,1);
        lcd_P4.print(">");
    }
    else if (cursorPosition_P4 == 2) {
        lcd_P4.setCursor(0,2);
        lcd_P4.print(">");
    }
    else if (cursorPosition_P4 == 3) {
        lcd_P4.setCursor(0,3);
        lcd_P4.print(">");
    }
  }
  else{
    // Should set the editing cursor if not on main scroll
    if (cursorPosition_P4 == 0) {
        lcd_P4.setCursor(18,0);
        lcd_P4.print("<<");
    }
    else if (cursorPosition_P4 == 1) {
        lcd_P4.setCursor(18,1);
        lcd_P4.print("<<");
    }
    else if (cursorPosition_P4 == 2) {
        lcd_P4.setCursor(18,2);
        lcd_P4.print("<<");
    }
    else if (cursorPosition_P4 == 3) {
        lcd_P4.setCursor(18,3);
        lcd_P4.print("<<");
    }
  }
}
void salaryClick_P1() {
  //Serial.print(player_1_section_tracker);
  activeButton = 0;
  readKey = analogRead(P1PIN);
  unsigned long currentMillis = millis();
 
  if(readKey < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey = analogRead(P1PIN);
  }
  
  if (activeButton == 0 && player_1_section_tracker == 1 && readKey > 600) {
    int button;
    button = buttonRead_P1(readKey);
    switch (button) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        break;
      case 2: // Increasing the value of the salary
        button = 0;
        if (salary_P1 != MAX_SALARIES) { //The max salary count
          lcd_P1.setCursor(15, 0);
          lcd_P1.print("   ");
          salary_P1++;
          lcd_P1.setCursor(15, 0);
          lcd_P1.print(salaries[salary_P1]);   
        }
        else {  //Should take you back to 0
          lcd_P1.setCursor(15, 0);
          lcd_P1.print("   ");
          salary_P1 = 0;
          lcd_P1.setCursor(15, 0);
          lcd_P1.print(salaries[salary_P1]);  
        }
        
        activeButton = 1;
        break;
      case 3: // Decreasing the value of the salary
       button = 0;
        if (salary_P1 != startSalary) { //The min salary count
          lcd_P1.setCursor(15, 0);
          lcd_P1.print("   ");
          salary_P1--;
          lcd_P1.setCursor(15, 0);
          lcd_P1.print(salaries[salary_P1]);   
        }
        else {  //Should take you back to the max
          lcd_P1.setCursor(15, 0);
          lcd_P1.print("   ");
          salary_P1 = MAX_SALARIES;
          lcd_P1.setCursor(15, 0);
          lcd_P1.print(salaries[salary_P1]);  
        }    
        activeButton = 1;
        break;
      case 4: // Getting back out of the editing variables
       button = 0;
       
        mainMenuDraw_P1();
        player_1_section_tracker = 0;
        drawCursor_P1();
        activeButton = 1;

        break;
    }
    readKey = 0;
  }
}
void salaryClick_P2() {
  
  int activeButton2 = 0;
  readKey2 = analogRead(P2PIN);
  unsigned long currentMillis = millis();
 
  if(readKey2 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey2 = analogRead(P2PIN);
  }
  if (activeButton2 == 0 && player_2_section_tracker == 1 && readKey2 > 600) {
    int button2;
    button2 = buttonRead_P2(readKey2);
    switch (button2) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        break;
      case 2: // Increasing the value of the salary
        button2 = 0;
        if (salary_P2 != MAX_SALARIES) { //The max salary count
          lcd_P2.setCursor(15, 0);
          lcd_P2.print("   ");
          salary_P2++;
          lcd_P2.setCursor(15, 0);
          lcd_P2.print(salaries[salary_P2]);   
        }
        else {  //Should take you back to 0
          lcd_P2.setCursor(15, 0);
          lcd_P2.print("   ");
          salary_P2 = 0;
          lcd_P2.setCursor(15, 0);
          lcd_P2.print(salaries[salary_P2]);  
        }
        
        activeButton2 = 1;
        break;
      case 3: // Decreasing the value of the salary
       button2 = 0;
        if (salary_P2 != startSalary) { //The min salary count
          lcd_P2.setCursor(15, 0);
          lcd_P2.print("   ");
          salary_P2--;
          lcd_P2.setCursor(15, 0);
          lcd_P2.print(salaries[salary_P2]);   
        }
        else {  //Should take you back to the max
          lcd_P2.setCursor(15, 0);
          lcd_P2.print("   ");
          salary_P2 = MAX_SALARIES;
          lcd_P2.setCursor(15, 0);
          lcd_P2.print(salaries[salary_P2]);  
        }    
        activeButton2 = 1;
        break;
      case 4: // Getting back out of the editing variables
       button2 = 0;
       
        mainMenuDraw_P2();
        player_2_section_tracker = 0;
        drawCursor_P2();
        activeButton2 = 1;
        break;
    }
    readKey2 = 0;
  }
}
void salaryClick_P3() {
  
  int activeButton3 = 0;
  readKey3 = analogRead(P3PIN);
  unsigned long currentMillis = millis();
 
  if(readKey3 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey3 = analogRead(P3PIN);
  }

  if (activeButton3 == 0 && player_3_section_tracker == 1 && readKey3 > 600) {
    int button3;
    button3 = buttonRead_P3(readKey3);
    switch (button3) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        break;
      case 2: // Increasing the value of the salary
        button3 = 0;
        if (salary_P3 != MAX_SALARIES) { //The max salary count
          lcd_P3.setCursor(15, 0);
          lcd_P3.print("   ");
          salary_P3++;
          lcd_P3.setCursor(15, 0);
          lcd_P3.print(salaries[salary_P3]);   
        }
        else {  //Should take you back to 0
          lcd_P3.setCursor(15, 0);
          lcd_P3.print("   ");
          salary_P3 = 0;
          lcd_P3.setCursor(15, 0);
          lcd_P3.print(salaries[salary_P3]);  
        }
        
        activeButton3 = 1;
        break;
      case 3: // Decreasing the value of the salary
       button3 = 0;
        if (salary_P3 != startSalary) { //The min salary count
          lcd_P3.setCursor(15, 0);
          lcd_P3.print("   ");
          salary_P3--;
          lcd_P3.setCursor(15, 0);
          lcd_P3.print(salaries[salary_P3]);   
        }
        else {  //Should take you back to the max
          lcd_P3.setCursor(15, 0);
          lcd_P3.print("   ");
          salary_P3 = MAX_SALARIES;
          lcd_P3.setCursor(15, 0);
          lcd_P3.print(salaries[salary_P3]);  
        }    
        activeButton3 = 1;
        break;
      case 4: // Getting back out of the editing variables
       button3 = 0;
       
        mainMenuDraw_P3();
        player_3_section_tracker = 0;
        drawCursor_P3();
        activeButton3 = 1;
        break;
    }
    readKey3 = 0;
  }
}
void salaryClick_P4() {
  
  int activeButton4 = 0;
  readKey4 = analogRead(P4PIN);
  unsigned long currentMillis = millis();
 
  if(readKey4 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey4 = analogRead(P4PIN);
  }
  if (activeButton4 == 0 && player_4_section_tracker == 1 && readKey4 > 600) {
    int button4;
    button4 = buttonRead_P4(readKey4);
    switch (button4) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        break;
      case 2: // Increasing the value of the salary
        button4 = 0;
        if (salary_P4 != MAX_SALARIES) { //The max salary count
          lcd_P4.setCursor(15, 0);
          lcd_P4.print("   ");
          salary_P4++;
          lcd_P4.setCursor(15, 0);
          lcd_P4.print(salaries[salary_P4]);   
        }
        else {  //Should take you back to 0
          lcd_P4.setCursor(15, 0);
          lcd_P4.print("   ");
          salary_P4 = 0;
          lcd_P4.setCursor(15, 0);
          lcd_P4.print(salaries[salary_P4]);  
        }
        
        activeButton4 = 1;
        break;
      case 3: // Decreasing the value of the salary
       button4 = 0;
        if (salary_P4 != startSalary) { //The min salary count
          lcd_P4.setCursor(15, 0);
          lcd_P4.print("   ");
          salary_P4--;
          lcd_P4.setCursor(15, 0);
          lcd_P4.print(salaries[salary_P4]);   
        }
        else {  //Should take you back to the max
          lcd_P4.setCursor(15, 0);
          lcd_P4.print("   ");
          salary_P4 = MAX_SALARIES;
          lcd_P4.setCursor(15, 0);
          lcd_P4.print(salaries[salary_P4]);  
        }    
        activeButton4 = 1;
        break;
      case 4: // Getting back out of the editing variables
       button4 = 0;
       
        mainMenuDraw_P4();
        player_4_section_tracker = 0;
        drawCursor_P4();
        activeButton4 = 1;
        break;
    }
    readKey4 = 0;
  }
}
void generatorClick_P1() {

  int activeButton = 0;
  unsigned long currentMillis = millis();
  readKey = analogRead(P1PIN);
 
  if(readKey < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey = analogRead(P1PIN);
  }
  if (activeButton == 0 && player_1_section_tracker == 2 && readKey > 600) {
    int button;
    button = buttonRead_P1(readKey);
    switch (button) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        break;
      case 2: // Increasing the value of the variable
        button = 0;
        if (generators_P1 != MAX_GENERATORS) { //The max generator count
          lcd_P1.setCursor(15, 1);
          lcd_P1.print("   ");
          generators_P1++;
          lcd_P1.setCursor(15, 1);
          lcd_P1.print(generators_P1);   
        }
        else {  //Should take you back to 0
          lcd_P1.setCursor(15, 1);
          lcd_P1.print("   ");
          generators_P1 = 0;
          lcd_P1.setCursor(15, 1);
          lcd_P1.print(generators_P1);  
        }      
        activeButton = 1;
        break;
      case 3: // Decreasing the menu
       button = 0;
        if (generators_P1 != 0) { //The max salary count
          lcd_P1.setCursor(15, 1);
          lcd_P1.print("   ");
          generators_P1--;
          lcd_P1.setCursor(15, 1);
          lcd_P1.print(generators_P1);   
        }
        else {  //Should take you back to max
          lcd_P1.setCursor(15, 1);
          lcd_P1.print("   ");
          generators_P1 = MAX_GENERATORS;
          lcd_P1.setCursor(15, 1);
          lcd_P1.print(generators_P1);  
        }      
        activeButton = 1;
        break;
      case 4: // Getting back out of the editing variables
       button = 0;
        
        mainMenuDraw_P1();
        player_1_section_tracker = 0;
        drawCursor_P1();
        activeButton = 1;
        //leds_P1(generators_P1);
        break;
    }
    readKey = 0;
  }
}
void generatorClick_P2() {
  
  activeButton2 = 0;
  readKey2 = analogRead(P2PIN);
  unsigned long currentMillis = millis();
 
  if(readKey2 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey2 = analogRead(P2PIN);
  }
  if (activeButton2 == 0 && player_2_section_tracker == 2 && readKey2 > 600) {
    int button2;
    button2 = buttonRead_P2(readKey2);
    switch (button2) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        break;
      case 2: // Increasing the value of the variable
        button2 = 0;
        if (generators_P2 != MAX_GENERATORS) { //The max generator count
          lcd_P2.setCursor(15, 1);
          lcd_P2.print("   ");
          generators_P2++;
          lcd_P2.setCursor(15, 1);
          lcd_P2.print(generators_P2);   
        }
        else {  //Should take you back to 0
          lcd_P2.setCursor(15, 1);
          lcd_P2.print("   ");
          generators_P2 = 0;
          lcd_P2.setCursor(15, 1);
          lcd_P2.print(generators_P2);  
        }      
        activeButton2 = 1;
        break;
      case 3: // Decreasing the menu
       button2 = 0;
        if (generators_P2 != 0) { //The max salary count
          lcd_P2.setCursor(15, 1);
          lcd_P2.print("   ");
          generators_P2--;
          lcd_P2.setCursor(15, 1);
          lcd_P2.print(generators_P2);   
        }
        else {  //Should take you back to max
          lcd_P2.setCursor(15, 1);
          lcd_P2.print("   ");
          generators_P2 = MAX_GENERATORS;
          lcd_P2.setCursor(15, 1);
          lcd_P2.print(generators_P2);  
        }      
        activeButton2 = 1;
        break;
      case 4: // Getting back out of the editing variables
       button2 = 0;
        
        mainMenuDraw_P2();
        player_2_section_tracker = 0;
        drawCursor_P2();
        activeButton2 = 1;
        break;
    }
    readKey2 = 0;
  }
}
void generatorClick_P3() {
  
  int activeButton3 = 0;
  readKey3 = analogRead(P3PIN);
  unsigned long currentMillis = millis();
 
  if(readKey3 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey3 = analogRead(P3PIN);
  }
  if (activeButton3 == 0 && player_3_section_tracker == 2 && readKey3 > 600) {
    int button3;
    button3 = buttonRead_P3(readKey3);
    switch (button3) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        break;
      case 2: // Increasing the value of the variable
        button3 = 0;
        if (generators_P3 != MAX_GENERATORS) { //The max generator count
          lcd_P3.setCursor(15, 1);
          lcd_P3.print("   ");
          generators_P3++;
          lcd_P3.setCursor(15, 1);
          lcd_P3.print(generators_P3);   
        }
        else {  //Should take you back to 0
          lcd_P3.setCursor(15, 1);
          lcd_P3.print("   ");
          generators_P3 = 0;
          lcd_P3.setCursor(15, 1);
          lcd_P3.print(generators_P3);  
        }      
        activeButton3 = 1;
        break;
      case 3: // Decreasing the menu
       button3 = 0;
        if (generators_P3 != 0) { //The max salary count
          lcd_P3.setCursor(15, 1);
          lcd_P3.print("   ");
          generators_P3--;
          lcd_P3.setCursor(15, 1);
          lcd_P3.print(generators_P3);   
        }
        else {  //Should take you back to max
          lcd_P3.setCursor(15, 1);
          lcd_P3.print("   ");
          generators_P3 = MAX_GENERATORS;
          lcd_P3.setCursor(15, 1);
          lcd_P3.print(generators_P3);  
        }      
        activeButton3 = 1;
        break;
      case 4: // Getting back out of the editing variables
       button3 = 0;
        
        mainMenuDraw_P3();
        player_3_section_tracker = 0;
        drawCursor_P3();
        activeButton3 = 1;
        break;
    }
    readKey3 = 0;
  }
}
void generatorClick_P4() {
  
  int activeButton4 = 0;
  readKey4 = analogRead(P4PIN);
  unsigned long currentMillis = millis();
 
  if(readKey4 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey4 = analogRead(P4PIN);
  }
  if (activeButton4 == 0 && player_4_section_tracker == 2 && readKey4 > 600) {
    int button4;
    button4 = buttonRead_P4(readKey4);
    switch (button4) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        break;
      case 2: // Increasing the value of the variable
        button4 = 0;
        if (generators_P4 != MAX_GENERATORS) { //The max generator count
          lcd_P4.setCursor(15, 1);
          lcd_P4.print("   ");
          generators_P4++;
          lcd_P4.setCursor(15, 1);
          lcd_P4.print(generators_P4);   
        }
        else {  //Should take you back to 0
          lcd_P4.setCursor(15, 1);
          lcd_P4.print("   ");
          generators_P4 = 0;
          lcd_P4.setCursor(15, 1);
          lcd_P4.print(generators_P4);  
        }      
        activeButton4 = 1;
        break;
      case 3: // Decreasing the menu
       button4 = 0;
        if (generators_P4 != 0) { //The max salary count
          lcd_P4.setCursor(15, 1);
          lcd_P4.print("   ");
          generators_P4--;
          lcd_P4.setCursor(15, 1);
          lcd_P4.print(generators_P4);   
        }
        else {  //Should take you back to max
          lcd_P4.setCursor(15, 1);
          lcd_P4.print("   ");
          generators_P4 = MAX_GENERATORS;
          lcd_P4.setCursor(15, 1);
          lcd_P4.print(generators_P4);  
        }      
        activeButton4 = 1;
        break;
      case 4: // Getting back out of the editing variables
       button4 = 0;
        
        mainMenuDraw_P4();
        player_4_section_tracker = 0;
        drawCursor_P4();
        activeButton = 1;
        break;
    }
    readKey4 = 0;
  }
}
//Determines if the player is reneng or not
void renewableClick_P1() {
  activeButton = 0;
  readKey = analogRead(P1PIN);
  unsigned long currentMillis = millis();
 
  if(readKey < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey = analogRead(P1PIN);
  }
  if (activeButton == 0 && player_1_section_tracker == 3 && readKey > 600) {
    int button;
    button = buttonRead_P1(readKey);
    switch (button) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        break;
      case 2: // Increasing the value of the variable
        button = 0;
          lcd_P1.setCursor(15, 2);
          lcd_P1.print("   ");
          renewable_1 = true;
          lcd_P1.setCursor(15, 2);
          lcd_P1.print("YES");   
      
        activeButton = 1;
        break;
      case 3: // Decreasing the value
       button = 0;
          lcd_P1.setCursor(15, 2);
          lcd_P1.print("   ");
          renewable_1 = false;
          lcd_P1.setCursor(15, 2);
          lcd_P1.print("NO");   
              
        activeButton = 1;
        break;
      case 4: // Getting back out of the editing variables
       button = 0;

        player_1_section_tracker = 0;
        mainMenuDraw_P1();
        drawCursor_P1();
        activeButton = 1;
        //leds_P1(generators_P1);
        break;
      }
      readKey = 0;
  }
}
void renewableClick_P2() {
  
  int activeButton2 = 0;
  readKey2 = analogRead(P2PIN);
  unsigned long currentMillis = millis();
 
  if(readKey2 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey2 = analogRead(P2PIN);
  }
  if (activeButton2 == 0 && player_2_section_tracker == 3 && readKey2 > 600) {
    int button2;
    button2 = buttonRead_P2(readKey2);
    switch (button2) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        break;
      case 2: // Increasing the value of the variable
        button2 = 0;
          lcd_P2.setCursor(15, 2);
          lcd_P2.print("   ");
          renewable_2 = true;
          lcd_P2.setCursor(15, 2);
          lcd_P2.print("YES");   
      
        activeButton2 = 1;
        break;
      case 3: // Decreasing the value
       button2 = 0;
          lcd_P2.setCursor(15, 2);
          lcd_P2.print("   ");
          renewable_2 = false;
          lcd_P2.setCursor(15, 2);
          lcd_P2.print("NO");   
              
        activeButton2 = 1;
        break;
      case 4: // Getting back out of the editing variables
       button2 = 0;

        player_2_section_tracker = 0;
        mainMenuDraw_P2();
        drawCursor_P2();
        activeButton2 = 1;      
        break;
      }
      readKey2 = 0;
  }
}
void renewableClick_P3() {
  
  int activeButton3 = 0;
  readKey3 = analogRead(P3PIN);
  unsigned long currentMillis = millis();
 
  if(readKey3 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey3 = analogRead(P3PIN);
  }
  if (activeButton3 == 0 && player_3_section_tracker == 3 && readKey3 > 600) {
    int button3;
    button3 = buttonRead_P3(readKey3);
    switch (button3) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        break;
      case 2: // Increasing the value of the variable
        button3 = 0;
          lcd_P3.setCursor(15, 2);
          lcd_P3.print("   ");
          renewable_3 = true;
          lcd_P3.setCursor(15, 2);
          lcd_P3.print("YES");   
      
        activeButton3 = 1;
        break;
      case 3: // Decreasing the value
       button3 = 0;
          lcd_P3.setCursor(15, 2);
          lcd_P3.print("   ");
          renewable_3 = false;
          lcd_P3.setCursor(15, 2);
          lcd_P3.print("NO");   
              
        activeButton3 = 1;
        break;
      case 4: // Getting back out of the editing variables
       button3 = 0;
        
        player_3_section_tracker = 0;
        mainMenuDraw_P3();
        drawCursor_P3();
        activeButton3 = 1;
        break;
      }
      readKey3 = 0;
  }
}
void renewableClick_P4() {
  
  int activeButton4 = 0;
  readKey4 = analogRead(P4PIN);
  unsigned long currentMillis = millis();
 
  if(readKey4 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey4 = analogRead(P4PIN);
  }
  if (activeButton4 == 0 && player_4_section_tracker == 3 && readKey4 > 600) {
    int button4;
    button4 = buttonRead_P4(readKey4);
    switch (button4) {
      case 0: // When button returns as 0 there is no action taken
        break;
      case 1:  // This case will execute if the "select" button is pressed
        break;
      case 2: // Increasing the value of the variable
        button4 = 0;
          lcd_P4.setCursor(15, 2);
          lcd_P4.print("   ");
          renewable_4 = true;
          lcd_P4.setCursor(15, 2);
          lcd_P4.print("YES");   
      
        activeButton4 = 1;
        break;
      case 3: // Decreasing the value
       button4 = 0;
          lcd_P4.setCursor(15, 2);
          lcd_P4.print("   ");
          renewable_4 = false;
          lcd_P4.setCursor(15, 2);
          lcd_P4.print("NO");   
              
        activeButton4 = 1;
        break;
      case 4: // Getting back out of the editing variables
       button4 = 0;
        
        mainMenuDraw_P4();
        drawCursor_P4();
        activeButton4 = 1;
        player_4_section_tracker = 0;
        break;
      }
      readKey = 0;
  }
}
void finishedClick_P1() {
  // End game message
  int activeButton = 0;
  if (player_1_section_tracker == 4) {
        
        lcd_P1.clear();
        lcd_P1.setCursor(2, 1);
        lcd_P1.print("CONGRADULATIONS!!");
        delay(5000);
        lcd_P1.clear();
        lcd_P1.noBacklight();
        player_1_section_tracker == 4;
  }  
  activeButton = 0;
  readKey = analogRead(P1PIN);
  unsigned long currentMillis = millis();
 
  if(readKey < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey = analogRead(P1PIN);
  }
  if (activeButton == 0 && player_1_section_tracker == 4 && readKey > 600) {
    int button;
    button = buttonRead_P1(readKey);
    switch (button) {
     case 0:
      break;
     case 1:
      break;
     case 2:
      break;
     case 3:
      break;
     case 4: // Getting back out of the editing variables
       button = 0;

        lcd_P1.backlight();

        player_1_section_tracker = 0;
        mainMenuDraw_P1();
        drawCursor_P1();
        activeButton = 1;
        break;
    }
    readKey = 0;
  }
}
void finishedClick_P2() {
  // End game message
  int activeButton2 = 0;
  if (player_2_section_tracker == 4) {
        
        lcd_P2.clear();
        lcd_P2.setCursor(2, 1);
        lcd_P2.print("CONGRADULATIONS!!");
        delay(5000);
        lcd_P2.clear();
        lcd_P2.noBacklight();
  }
  readKey = analogRead(P2PIN);
  unsigned long currentMillis = millis();
 
  if(readKey2 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey2 = analogRead(P2PIN);
  }
  if (activeButton2 == 0 && player_2_section_tracker == 4 && readKey2 > 600) {
    int button2;
    button2 = buttonRead_P2(readKey2);
    switch (button2) {
     case 0:
      break;
     case 1:
      break;
     case 2:
      break;
     case 3:
      break;
     case 4: // Getting back out of the editing variables
       button2 = 0;

        lcd_P2.backlight();

        player_2_section_tracker = 0;
        mainMenuDraw_P2();
        drawCursor_P2();
        activeButton2 = 1;
        break;
    }
    readKey2 = 0;
  }
}
void finishedClick_P3() {
  // End game message
  int activeButton3 = 0;
  if (player_3_section_tracker == 4) {
        
        lcd_P3.clear();
        lcd_P3.setCursor(2, 1);
        lcd_P3.print("CONGRADULATIONS!!");
        delay(5000);

        lcd_P3.clear();
        lcd_P3.noBacklight();
  }  
  readKey3 = analogRead(P3PIN);
  unsigned long currentMillis = millis();
 
  if(readKey3 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey3 = analogRead(P3PIN);
  } 
  if (activeButton3 == 0 && player_3_section_tracker == 4 && readKey3 > 600) {
    int button3;
    button3 = buttonRead_P3(readKey3);
    switch (button3) {
     case 0:
      break;
     case 1:
      break;
     case 2:
      break;
     case 3:
      break;
     case 4: // Getting back out of the editing variables
       button3 = 0;

        lcd_P3.backlight();

        player_3_section_tracker = 0;
        mainMenuDraw_P3();
        drawCursor_P3();
        activeButton3 = 1;
        break;
    }
    readKey3 = 0;
  }
}
void finishedClick_P4() {
  // End game message
  int activeButton4 = 0;
  if (player_4_section_tracker == 4) {
        
        lcd_P4.clear();
        lcd_P4.setCursor(2, 1);
        lcd_P4.print("CONGRADULATIONS!!");
        delay(5000);

        lcd_P4.clear();
        lcd_P4.noBacklight();
  }  
  readKey4 = analogRead(P4PIN);
  unsigned long currentMillis = millis();
 
  if(readKey4 < 600 && (currentMillis - previousMillis > interval)) {
    // save the last time you blinked the LED 
    previousMillis = currentMillis;   
    readKey4 = analogRead(P4PIN);
  }
  if (activeButton4 == 0 && player_4_section_tracker == 4 && readKey4 > 600) {
    int button4;
    button4 = buttonRead_P4(readKey4);
    switch (button4) {
     case 0:
      break;
     case 1:
      break;
     case 2:
      break;
     case 3:
      break;
     case 4: // Getting back out of the editing variables
       button4 = 0;

        lcd_P4.backlight();

        player_4_section_tracker = 0;
        mainMenuDraw_P4();
        drawCursor_P4();
        activeButton4 = 1;
        break;
    }
    }
}
// This function is called whenever a button press is evaluated. The LCD shield works by observing a voltage drop across the buttons all hooked up to A0.
int buttonRead_P1(int x) {
  int result = 0;
  
  Serial.print(result);
 
      if (x > 880 && x < 940) {
        result = 1; // select
        delay(100);
      } 
      if (x > 780 && x < 850) {
        result = 2; // up
        delay(100); // To debounce
      }
      if (x > 730 && x < 780) {
        result = 3; // down
        delay(100); // To debounce
      } 
      if (x > 600 && x < 680) {
        result = 4; // back
        delay(100); // To debounce
      }
      return result;
}
int buttonRead_P2(int x) {
  int result = 0;
  
  Serial.print(result);
 
      if (x > 880 && x < 940) {
        result = 1; // select
        delay(100);
      } 
      if (x > 780 && x < 850) {
        result = 2; // up
        delay(100); // To debounce
      }
      if (x > 730 && x < 780) {
        result = 3; // down
        delay(100); // To debounce
      } 
      if (x > 600 && x < 680) {
        result = 4; // back
        delay(100); // To debounce
      }
      return result;
}
int buttonRead_P3(int x) {
  int result = 0;
  
  Serial.print(result);
 
      if (x > 880 && x < 940) {
        result = 1; // select
        delay(100);
      } 
      if (x > 780 && x < 850) {
        result = 2; // up
        delay(100); // To debounce
      }
      if (x > 730 && x < 780) {
        result = 3; // down
        delay(100); // To debounce
      } 
      if (x > 600 && x < 680) {
        result = 4; // back
        delay(100); // To debounce
      }
      return result;
}
int buttonRead_P4(int x) {
  int result = 0;
  
  Serial.print(result);
 
      if (x > 880 && x < 940) {
        result = 1; // select
        delay(100);
      } 
      if (x > 780 && x < 850) {
        result = 2; // up
        delay(100); // To debounce
      }
      if (x > 730 && x < 780) {
        result = 3; // down
        delay(100); // To debounce
      } 
      if (x > 600 && x < 680) {
        result = 4; // back
        delay(100); // To debounce
      }
      return result;
}
void leds_P1 (int generators, int salary){
   uint32_t salary_colour = strip.Color(50, 0, 0);

   bool rainbowed = false;
   bool chased = false;  
   bool wiped = false;

   if(salary >= 0 && salary <= 5 && renewable_1 == false){
      //set colour to red
      salary_colour = strip.Color(50, 0, 0); //red 
    }
    else if(salary >= 0 && salary <= 5 && renewable_1 == true){
      //set colour to red
      salary_colour = strip.Color(0, 50, 0); //green 
    }
    else if(salary >= 6 && salary <= 10 && renewable_1 == false){
      salary_colour = strip.Color(150, 0, 0); // red
    }
    else if(salary >= 6 && salary <= 10 && renewable_1 == true){
      salary_colour = strip.Color(0, 0, 150); // blue
    }
    else if(salary >= 11 && salary<= 20 && renewable_1 == false){
      salary_colour = strip.Color(255, 0, 0); // red
    }
    else if(salary >= 11 && salary<= 20 && renewable_1 == true){
      salary_colour = strip.Color(20, 245, 40); // apple green
    }
    else if(salary >= 21 && salary <= 30 && renewable_1 == false){
      salary_colour = strip.Color(255, 50, 0); // orange
      //Serial.print("Orange");
    }
    else if(salary >= 21 && salary <= 30 && renewable_1 == true){
      salary_colour = strip.Color(255, 155, 0);  // yellow
    }
    else if(salary >= 31 && salary<= 50 && renewable_1 == false){
      salary_colour = strip.Color(150, 0, 255); // lavender/purple
    }
    else if(salary >= 31 && salary<= 50 && renewable_1 == true){
      salary_colour = strip.Color(0, 255, 255); // aqua
    }

   for(int i=0; i<20; i++) { // For each pixel...
        // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255
        // Here we're using a moderately bright green color:
        strip.setPixelColor(i, salary_colour);
        strip.show();   // Send the updated pixel colors to the hardware.
   }

   switch(generators){
    case 0:
      rainbowed = false;
      chased = false;
      wiped = false;
      break;
    case 1:
    rainbowed = false;
    chased = false;

       if (wiped == false){ 
          colorWipe(salary_colour, 200, 0, 20);
          wiped = true;
        } 
      
      break;
    case 2:
      strip.setPixelColor(0, 255, 0, 0);
      strip.setPixelColor(19, 255, 0, 0);
      strip.setPixelColor(1, 0, 0, 255);
      strip.setPixelColor(18, 0, 0, 255);
      strip.setPixelColor(2, 0, 255, 0);
      strip.setPixelColor(17, 0, 255, 0);
      
      rainbowed = false;
      chased = false;
      wiped = false;
      break;
    case 3:
    rainbowed = false;
    wiped = false;
 
      if (chased == false){ 
        theaterChase(salary_colour, 200, 0, 20);
        chased = true;
        for(int i=0; i<20; i++) { // For each pixel...
        // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255
        // Here we're using a moderately bright green color:
        strip.setPixelColor(i, salary_colour);
        strip.show();   // Send the updated pixel colors to the hardware.
        }
      }
      break;
    case 4:
    chased = false;
    wiped = false;
    
      if (rainbowed == false){ 
        rainbow(5, 5, 15);
        rainbowed = true;
      } 
      break;
   }
   strip.show();
}
void leds_P2 (int generators, int salary){
   uint32_t salary_colour = strip.Color(50, 0, 0);

   bool rainbowed_2 = false;
   bool chased_2 = false;  
   bool wiped_2 = false;

   if(salary >= 0 && salary <= 5 && renewable_2 == false){
      //set colour to red
      salary_colour = strip.Color(50, 0, 0); //red 
    }
    else if(salary >= 0 && salary <= 5 && renewable_2 == true){
      //set colour to red
      salary_colour = strip.Color(0, 50, 0); //green 
    }
    else if(salary >= 6 && salary <= 10 && renewable_2 == false){
      salary_colour = strip.Color(150, 0, 0); // red
    }
    else if(salary >= 6 && salary <= 10 && renewable_2 == true){
      salary_colour = strip.Color(0, 0, 150); // blue
    }
    else if(salary >= 11 && salary<= 20 && renewable_2 == false){
      salary_colour = strip.Color(255, 0, 0); // red
    }
    else if(salary >= 11 && salary<= 20 && renewable_2 == true){
      salary_colour = strip.Color(20, 245, 40); // apple green
    }
    else if(salary >= 21 && salary <= 30 && renewable_2 == false){
      salary_colour = strip.Color(255, 50, 0); // orange
      //Serial.print("Orange");
    }
    else if(salary >= 21 && salary <= 30 && renewable_2 == true){
      salary_colour = strip.Color(255, 155, 0);  // yellow
    }
    else if(salary >= 31 && salary<= 50 && renewable_2 == false){
      salary_colour = strip.Color(150, 0, 255); // lavender/purple
    }
    else if(salary >= 31 && salary<= 50 && renewable_2 == true){
      salary_colour = strip.Color(0, 255, 255); // aqua
    }

   for(int i=20; i<40; i++) { // For each pixel...
        // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255
        // Here we're using a moderately bright green color:
        strip.setPixelColor(i, salary_colour);
        strip.show();   // Send the updated pixel colors to the hardware.
   }

   switch(generators){
    case 0:
      rainbowed_2 = false;
      chased_2 = false;
      wiped_2 = false;
      break;
    case 1:
    rainbowed_2 = false;
    chased_2 = false;

       if (wiped_2 == false){ 
        colorWipe(salary_colour, 200, 20, 40);
        wiped_2 = true;
        } 
      
      break;
    case 2:
      strip.setPixelColor(20, 255, 0, 0);
      strip.setPixelColor(39, 255, 0, 0);
      strip.setPixelColor(21, 0, 0, 255);
      strip.setPixelColor(38, 0, 0, 255);
      strip.setPixelColor(22, 0, 255, 0);
      strip.setPixelColor(37, 0, 255, 0);
      
      rainbowed_2 = false;
      chased_2 = false;
      wiped_2 = false;
      break;
    case 3:
    rainbowed_2 = false;
    wiped_2 = false;
 
      if (chased_2 == false){ 
        theaterChase(salary_colour, 200, 20, 40);
        chased_2 = true;
        for(int i=20; i<40; i++) { // For each pixel...
        // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255
        // Here we're using a moderately bright green color:
        strip.setPixelColor(i, salary_colour);
        strip.show();   // Send the updated pixel colors to the hardware.
        }
      }
      break;
    case 4:
    chased_2 = false;
    wiped_2 = false;
    
      if (rainbowed_2 == false){ 
        rainbow(5, 25, 35);
        rainbowed_2 = true;
      } 
      break;
   }
   strip.show();
}
void leds_P3 (int generators, int salary){
   uint32_t salary_colour = strip.Color(50, 0, 0);
   //leds_P1_colour = leds_colour(salary_P1, renewable_1); // Finding the colour from players stats

   bool rainbowed_3 = false;
   bool chased_3 = false;  
   bool wiped_3 = false;
   //Serial.print(leds_P1_colour);

   if(salary >= 0 && salary <= 5 && renewable_3 == false){
      //set colour to red
      salary_colour = strip.Color(50, 0, 0); //red 
    }
    else if(salary >= 0 && salary <= 5 && renewable_3 == true){
      //set colour to red
      salary_colour = strip.Color(0, 50, 0); //green 
    }
    else if(salary >= 6 && salary <= 10 && renewable_3 == false){
      salary_colour = strip.Color(150, 0, 0); // red
    }
    else if(salary >= 6 && salary <= 10 && renewable_3 == true){
      salary_colour = strip.Color(0, 0, 150); // blue
    }
    else if(salary >= 11 && salary<= 20 && renewable_3 == false){
      salary_colour = strip.Color(255, 0, 0); // red
    }
    else if(salary >= 11 && salary<= 20 && renewable_3 == true){
      salary_colour = strip.Color(20, 245, 40); // apple green
    }
    else if(salary >= 21 && salary <= 30 && renewable_3 == false){
      salary_colour = strip.Color(255, 50, 0); // orange
      //Serial.print("Orange");
    }
    else if(salary >= 21 && salary <= 30 && renewable_3 == true){
      salary_colour = strip.Color(255, 155, 0);  // yellow
    }
    else if(salary >= 31 && salary<= 50 && renewable_3 == false){
      salary_colour = strip.Color(150, 0, 255); // lavender/purple
    }
    else if(salary >= 31 && salary<= 50 && renewable_3 == true){
      salary_colour = strip.Color(0, 255, 255); // aqua
    }

   for(int i=40; i<60; i++) { // For each pixel...
        // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255
        // Here we're using a moderately bright green color:
        strip.setPixelColor(i, salary_colour);
        strip.show();   // Send the updated pixel colors to the hardware.
   }

   switch(generators){
    case 0:
      rainbowed_3 = false;
      chased_3 = false;
      wiped_3 = false;
      break;
    case 1:
      rainbowed_3 = false;
      chased_3 = false;

       if (wiped_3 == false){ 
        colorWipe(salary_colour, 200, 40, 60);
        wiped_3 = true;
       } 
      
      break;
    case 2:
      strip.setPixelColor(40, 255, 0, 0);
      strip.setPixelColor(59, 255, 0, 0);
      strip.setPixelColor(41, 0, 0, 255);
      strip.setPixelColor(58, 0, 0, 255);
      strip.setPixelColor(42, 0, 255, 0);
      strip.setPixelColor(57, 0, 255, 0);
      
      rainbowed_3 = false;
      chased_3 = false;
      wiped_3 = false;
      break;
    case 3:
    rainbowed_3 = false;
    wiped_3 = false;
 
      if (chased_3 == false){ 
        theaterChase(salary_colour, 200, 40, 60);
        chased_3 = true;
        for(int i=40; i<60; i++) { // For each pixel...
        // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255
        // Here we're using a moderately bright green color:
        strip.setPixelColor(i, salary_colour);
        strip.show();   // Send the updated pixel colors to the hardware.
        }
      }
      break;
    case 4:
    chased_3 = false;
    wiped_3 = false;
    
      if (rainbowed_3 == false){ 
        rainbow(5, 45, 55);
        rainbowed_3 = true;
      } 
      break;
   }
   strip.show();
}
void leds_P4 (int generators, int salary){
   uint32_t salary_colour = strip.Color(50, 0, 0);
   bool rainbowed_4 = false;
   bool chased_4 = false;  
   bool wiped_4 = false;

   if(salary >= 0 && salary <= 5 && renewable_4 == false){
      //set colour to red
      salary_colour = strip.Color(50, 0, 0); //red 
    }
    else if(salary >= 0 && salary <= 5 && renewable_4 == true){
      //set colour to red
      salary_colour = strip.Color(0, 50, 0); //green 
    }
    else if(salary >= 6 && salary <= 10 && renewable_4 == false){
      salary_colour = strip.Color(150, 0, 0); // red
    }
    else if(salary >= 6 && salary <= 10 && renewable_4 == true){
      salary_colour = strip.Color(0, 0, 150); // blue
    }
    else if(salary >= 11 && salary<= 20 && renewable_4 == false){
      salary_colour = strip.Color(255, 0, 0); // red
    }
    else if(salary >= 11 && salary<= 20 && renewable_4 == true){
      salary_colour = strip.Color(20, 245, 40); // apple green
    }
    else if(salary >= 21 && salary <= 30 && renewable_4 == false){
      salary_colour = strip.Color(255, 50, 0); // orange
      //Serial.print("Orange");
    }
    else if(salary >= 21 && salary <= 30 && renewable_4 == true){
      salary_colour = strip.Color(255, 155, 0);  // yellow
    }
    else if(salary >= 31 && salary<= 50 && renewable_4 == false){
      salary_colour = strip.Color(150, 0, 255); // lavender/purple
    }
    else if(salary >= 31 && salary<= 50 && renewable_4 == true){
      salary_colour = strip.Color(0, 255, 255); // aqua
    }

   for(int i=60; i<80; i++) { // For each pixel...
        // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255
        // Here we're using a moderately bright green color:
        strip.setPixelColor(i, salary_colour);
        strip.show();   // Send the updated pixel colors to the hardware.
   }

   switch(generators){
    case 0:
      rainbowed_4 = false;
      chased_4 = false;
      wiped_4 = false;
      break;
    case 1:
    rainbowed_4 = false;
    chased_4 = false;

       if (wiped_4 == false){ 
        colorWipe(salary_colour, 200, 60, 80);
        wiped_4 = true;
       } 
      
      break;
    case 2:
      strip.setPixelColor(60, 255, 0, 0);
      strip.setPixelColor(79, 255, 0, 0);
      strip.setPixelColor(61, 0, 0, 255);
      strip.setPixelColor(78, 0, 0, 255);
      strip.setPixelColor(62, 0, 255, 0);
      strip.setPixelColor(77, 0, 255, 0);
      
      rainbowed_4 = false;
      chased_4 = false;
      wiped_4 = false;
      break;
    case 3:
    rainbowed_4 = false;
    wiped_4 = false;
 
      if (chased_4 == false){ 
        theaterChase(salary_colour, 200, 60, 80);
        chased_4 = true;
        for(int i=60; i<80; i++) { // For each pixel...
        // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255
        // Here we're using a moderately bright green color:
        strip.setPixelColor(i, salary_colour);
        strip.show();   // Send the updated pixel colors to the hardware.
        }
      }
      break;
    case 4:
    chased_4 = false;
    wiped_4 = false;
    
      if (rainbowed_4 == false){ 
        rainbow(5, 65, 75);
        rainbowed_4 = true;
      } 
      break;
   }
   strip.show();
}
void colorWipe(uint32_t color, int wait, int pixelStart,int pixelEnd) {
  for(int i=pixelStart; i<pixelEnd; i++) { // For each pixel in strip...
    strip.setPixelColor(i, color);         //  Set pixel's color (in RAM)
    strip.show();                          //  Update strip to match
    delay(wait);                           //  Pause for a moment
  }
}
void theaterChase(uint32_t color, int wait, int pixelStart,int pixelEnd) {
  for(int a=pixelStart; a<10; a++) {  // Repeat 10 times...
    for(int b=pixelStart; b<3; b++) { //  'b' counts from 0 to 2...
      strip.clear();         //   Set all pixels in RAM to 0 (off)
      // 'c' counts up from 'b' to end of strip in steps of 3...
      for(int c=b; c<pixelEnd; c += 3) {
        strip.setPixelColor(c, color); // Set pixel 'c' to value 'color'
      }
      strip.show(); // Update strip with new contents
      delay(wait);  // Pause for a moment
    }
  }
}
// Rainbow cycle along whole strip. Pass delay time (in ms) between frames.
void rainbow(int wait, int pixelStart, int pixelEnd) {
  // Hue of first pixel runs 5 complete loops through the color wheel.
  // Color wheel has a range of 65536 but it's OK if we roll over, so
  // just count from 0 to 5*65536. Adding 256 to firstPixelHue each time
  // means we'll make 5*65536/256 = 1280 passes through this outer loop:
  for(long firstPixelHue = 0; firstPixelHue < 5*65536; firstPixelHue += 256) {
    for(int i=pixelStart; i<pixelEnd; i++) { // For each pixel in strip...
      // Offset pixel hue by an amount to make one full revolution of the
      // color wheel (range of 65536) along the length of the strip
      // (strip.numPixels() steps):
      int pixelHue = firstPixelHue + (i * 65536L / strip.numPixels());
      // strip.ColorHSV() can take 1 or 3 arguments: a hue (0 to 65535) or
      // optionally add saturation and value (brightness) (each 0 to 255).
      // Here we're using just the single-argument hue variant. The result
      // is passed through strip.gamma32() to provide 'truer' colors
      // before assigning to each pixel:
      strip.setPixelColor(i, strip.gamma32(strip.ColorHSV(pixelHue)));
    }
    strip.show(); // Update strip with new contents
    delay(wait);  // Pause for a moment
  }
}
// Rainbow-enhanced theater marquee. Pass delay time (in ms) between frames.
void theaterChaseRainbow(int wait) {
  int firstPixelHue = 0;     // First pixel starts at red (hue 0)
  for(int a=0; a<5; a++) {  // Repeat 30 times...
    for(int b=0; b<3; b++) { //  'b' counts from 0 to 2...
      strip.clear();         //   Set all pixels in RAM to 0 (off)
      // 'c' counts up from 'b' to end of strip in increments of 3...
      for(int c=b; c<strip.numPixels(); c += 3) {
        // hue of pixel 'c' is offset by an amount to make one full
        // revolution of the color wheel (range 65536) along the length
        // of the strip (strip.numPixels() steps):
        int      hue   = firstPixelHue + c * 65536L / strip.numPixels();
        uint32_t color = strip.gamma32(strip.ColorHSV(hue)); // hue -> RGB
        strip.setPixelColor(c, color); // Set pixel 'c' to value 'color'
      }
      strip.show();                // Update strip with new contents
      delay(wait);                 // Pause for a moment
      firstPixelHue += 65536 / 90; // One cycle of color wheel over 90 frames
    }
  }
}  
